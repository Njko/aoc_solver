# Day 9: Explosives in Cyberspace

## Part 1

The problem asks us to calculate the decompressed length of a file. The file is compressed using markers like `(AxB)`, which means "repeat the next A characters B times".

### Strategy

1.  **Iterate**: Scan the string character by character.
2.  **Marker Detection**: If we encounter `(`, parse the marker `(AxB)`.
3.  **Process Marker**:
    *   Extract the next `A` characters (the data to repeat).
    *   Add `A * B` to the total length.
    *   Advance the index past the marker and the `A` characters.
4.  **Normal Characters**: If not a marker, just increment length by 1 and advance index by 1.

### Code Snippet

```python
length = 0
i = 0
while i < len(data):
    if data[i] == '(':
        match = re.match(r'\((\d+)x(\d+)\)', data[i:])
        char_count, repeat = map(int, match.groups())
        marker_len = match.end()
        i += marker_len
        
        # In Part 1, we just multiply the length of the data
        sub_len = char_count
        
        length += sub_len * repeat
        i += char_count
    else:
        length += 1
        i += 1
return length
```

## Part 2

The second part introduces *recursive* decompression. The decompressed data might contain more markers, which also need to be decompressed.

### Strategy

The logic is similar to Part 1, but when we process a marker `(AxB)`, we need to calculate the decompressed length of the `A` characters *recursively* before multiplying by `B`.

1.  **Recursive Function**: Create a function `_decompress(data, recursive=True)`.
2.  **Base Case**: If no markers are found, return the length of the string.
3.  **Recursive Step**: When a marker `(AxB)` is found:
    *   Extract the substring of length `A`.
    *   Call `_decompress(substring, recursive=True)` to get its full length.
    *   Add `decompressed_length * B` to the total length.

### Code Snippet

```python
def _decompress(self, data, recursive=False):
    length = 0
    i = 0
    while i < len(data):
        if data[i] == '(':
            match = re.match(r'\((\d+)x(\d+)\)', data[i:])
            char_count, repeat = map(int, match.groups())
            marker_len = match.end()
            i += marker_len
            
            sub_data = data[i:i+char_count]
            if recursive:
                sub_len = self._decompress(sub_data, recursive=True)
            else:
                sub_len = len(sub_data)
            
            length += sub_len * repeat
            i += char_count
        else:
            length += 1
            i += 1
    return length
```
