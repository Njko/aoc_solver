# Day 1: No Time for a Taxicab

## Part 1

The problem asks us to calculate the Manhattan distance from the starting point (0, 0) to the final destination after following a sequence of instructions. Each instruction consists of a turn (Left or Right) and a number of blocks to walk.

### Strategy

We can simulate the movement on a 2D grid. We start at `(0, 0)` facing North. We can represent the directions as integers: 0: North, 1: East, 2: South, 3: West.

For each instruction:
1.  **Turn**: Update the current direction.
    *   'R' (Right): `(direction + 1) % 4`
    *   'L' (Left): `(direction - 1 + 4) % 4` (adding 4 ensures the result is non-negative before modulo)
2.  **Move**: Update the coordinates `(x, y)` based on the new direction and the number of blocks.
    *   North: `y += blocks`
    *   East: `x += blocks`
    *   South: `y -= blocks`
    *   West: `x -= blocks`

After processing all instructions, the answer is `abs(x) + abs(y)`.

### Code Snippet

```python
x, y = 0, 0
# 0: N, 1: E, 2: S, 3: W
direction = 0

# dx, dy for directions N, E, S, W
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

for instruction in instructions:
    turn = instruction[0]
    blocks = int(instruction[1:])

    if turn == 'R':
        direction = (direction + 1) % 4
    elif turn == 'L':
        direction = (direction - 1 + 4) % 4
    
    x += blocks * dx[direction]
    y += blocks * dy[direction]

return abs(x) + abs(y)
```

## Part 2

The second part asks for the distance to the *first location visited twice*.

### Strategy

We can use the same simulation logic as Part 1, but we need to keep track of all visited locations. A set is suitable for this purpose for O(1) lookups.

Important detail: The problem states "if you visit a location twice". This includes intermediate steps when walking multiple blocks. So, instead of updating `x` and `y` by the full `blocks` amount at once, we must simulate walking one block at a time.

For each step of the walk:
1.  Update `x` and `y` by 1 unit in the current direction.
2.  Check if `(x, y)` is already in the `visited` set.
    *   If yes, this is the first location visited twice. Return `abs(x) + abs(y)`.
    *   If no, add `(x, y)` to `visited`.

### Code Snippet

```python
visited = {(0, 0)}

for instruction in instructions:
    # ... turn logic ...
    
    for _ in range(blocks):
        x += dx[direction]
        y += dy[direction]
        if (x, y) in visited:
            return abs(x) + abs(y)
        visited.add((x, y))
```
