# Walkthrough - Day 11 (2025)

## Problem Description
### Part 1
We need to count distinct paths in a DAG from `you` to `out`.

### Part 2
We need to count paths from `svr` to `out` that visit *both* `dac` and `fft`.

## Solution Approach
### Part 1
DFS with memoization counts paths between any two nodes.
`count_paths(start, end)`:
- If `start == end`, return 1.
- Else return sum of `count_paths(neighbor, end)` for all neighbors.

### Part 2
Since the graph is a DAG, a path visiting both `dac` and `fft` must visit them in one of two orders:
1. `svr -> ... -> dac -> ... -> fft -> ... -> out`
2. `svr -> ... -> fft -> ... -> dac -> ... -> out`

The total paths is the sum of paths for each order.
- Paths(Order 1) = `count_paths('svr', 'dac') * count_paths('dac', 'fft') * count_paths('fft', 'out')`
- Paths(Order 2) = `count_paths('svr', 'fft') * count_paths('fft', 'dac') * count_paths('dac', 'out')`

Because it's a DAG, cycles are impossible, so we don't need to worry about the same path visiting nodes multiple times in a loop.

## Key Code
```python
    def _count_paths(self, start_node, end_node):
        @lru_cache(maxsize=None)
        def dfs(node):
            if node == end_node:
                return 1
            if node not in self.adj:
                return 0
            return sum(dfs(neighbor) for neighbor in self.adj[node])
        return dfs(start_node)

    def part2(self) -> "str | int":
        # Order 1: svr -> dac -> fft -> out
        p1 = self._count_paths('svr', 'dac') * self._count_paths('dac', 'fft') * self._count_paths('fft', 'out')
        
        # Order 2: svr -> fft -> dac -> out
        p2 = self._count_paths('svr', 'fft') * self._count_paths('fft', 'dac') * self._count_paths('dac', 'out')
        
        return p1 + p2
```

## Verification Results
### Automated Tests
- **Part 1 Example**: Passed (`5`).
- **Part 1 Real**: `701`.
- **Part 2 Example**: Passed (`2`).
- **Part 2 Real**: `390108778818526`.

Run via:
```bash
python3 verify_day_11.py
```
