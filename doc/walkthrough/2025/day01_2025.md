# Advent of Code 2025 Solutions

## Day 01: Secret Entrance

### Problem Overview
The problem involves simulating a safe dial with numbers 0-99. The dial starts at 50. We receive a list of instructions to rotate the dial Left (L) or Right (R) by a certain amount.

### Part 1 Strategy
**Goal:** Count how many times the dial points to `0` *at the end* of an instruction.

**Approach:**
- Initialize `current` position to `50`.
- Iterate through each instruction `(direction, amount)`.
- Update `current` position:
  - If `L`: `current = (current - amount) % 100`
  - If `R`: `current = (current + amount) % 100`
- Check if `current == 0`. If so, increment the counter.

### Part 2 Strategy
**Goal:** Count how many times the dial points to `0` *at any point* during the rotation (including intermediate clicks).

**Approach:**
- Instead of simulating every single click (which could be slow for large amounts), we calculate the number of times `0` is visited mathematically.
- For each instruction:
  1. Calculate the distance from the `current` position to `0` in the given `direction`.
     - For `R` (forward): `dist = (100 - current) % 100`. (If `current` is 0, `dist` is 100).
     - For `L` (backward): `dist = current`. (If `current` is 0, `dist` is 100).
  2. Check if the rotation `amount` is large enough to reach `0` (`amount >= dist`).
  3. If it reaches `0`:
     - Count 1 for the first visit.
     - Calculate remaining steps: `remaining = amount - dist`.
     - Count additional visits for every full circle (100 steps) in the remaining steps: `remaining // 100`.
  4. Update `current` position as in Part 1.

**Key Insight:**
- The dial is circular with period 100.
- Calculating hits is `1 + (amount - distance_to_first_zero) // 100` if `amount >= distance_to_first_zero`.

### Code Reference
[day_01.py](file:///Users/a422gq/Documents/antigravity/earlydemo/aoc_agent/days/y2025/day_01.py)
