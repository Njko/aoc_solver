# Day 7: Laboratories (2025)

## Part 1

### Problem Description

We are exploring a "teleporter lab" and need to understand the behavior of tachyon beams in a "tachyon manifold".

The manifold is a grid containing:
-   Empty space (`.`)
-   Splitters (`^`)
-   A starting point (`S`)

**Rules**:
1.  A tachyon beam originates at `S` and moves **downward**.
2.  It passes freely through empty space.
3.  If it hits a splitter (`^`):
    -   The original beam stops.
    -   Two *new* beams appear at the immediate **left** and **right** of the splitter.
    -   These new beams also move downward.
4.  If multiple beams hit the same cell (e.g. a splitter or empty space) at the same time, they merge/act effectively as one wave front in that cell. The problem implies we tracking unique "beam activations" or simply simulating the flow. The specific metric requested is: **"How many times will the beam be split?"**

### Approach

The simulation can be modeled row by row, as beams only move downwards.

1.  **Parse Grid**: Read the grid into a 2D array.
2.  **Identify Start**: Find the column index of `S` in the first row (or wherever it appears).
3.  **Simulation Loop**:
    -   Maintain a set of `current_beams` containing the column indices of active beams in the current row.
    -   Iterate from the row immediately below `S` down to the bottom.
    -   For each row, determine the `next_beams` (columns) for the *next* row.
    -   For each active beam column `c`:
        -   Check the cell content at `grid[row][c]`.
        -   If it is a splitter (`^`):
            -   Increment `split_count`.
            -   Add `c-1` and `c+1` to `next_beams` (checking bounds).
        -   Else (empty space or S):
            -   The beam continues straight down: add `c` to `next_beams`.
4.  **Result**: The total count of split events encountered.

### Solution

The solution for my input was **1590**.

## Part 2

### Problem Description

We are now dealing with a "quantum tachyon manifold". Instead of just splitting the beam, each splitter creates two "timelines".
-   A single particle starts at `S`.
-   At each splitter `^`, the timeline splits: one where the particle goes left, one where it goes right.
-   We need to count the **total number of active timelines** (i.e., the total number of paths a single particle takes to reach the bottom).

### Approach

This is a path counting problem.
1.  **Count Tracking**: Instead of a set of active beam columns, use a Map (or `Counter`) where `key = column_index` and `value = number_of_timelines`.
2.  **Initial State**: At the start row (S), `counts[s_col] = 1`.
3.  **Simulation**:
    -   Iterate row by row downwards.
    -   For each active column `c` with count `N`:
        -   If cell is `^`: Add `N` to `next_counts[c-1]` and `next_counts[c+1]`. (The particle splits, so all `N` existing timelines now branch into two sets of `N` timelines).
        -   If cell is `.` or `S`: Add `N` to `next_counts[c]`.
4.  **Result**: Sum of all values in the final `counts` map.

### Solution

The solution for my input was **20571740188555**.

## Code Reference

[day_07.py](file:///Users/a422gq/Documents/antigravity/aoc_solver/solvers/days/y2025/day_07.py)
